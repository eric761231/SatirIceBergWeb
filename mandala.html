<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Áπ™Áï´Â£áÂüé</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Base color variables for easy theme management */
        :root {
            --bg-dark: #18181c;
            --bg-medium: #22223a;
            --bg-light: rgba(30, 30, 45, 0.98);
            --text-light: #f3f3f3;
            --primary-accent: #3498db;
            --danger-accent: #e74c3c;
            --border-color: rgba(255, 255, 255, 0.12);
            --shadow-color: rgba(0, 0, 0, 0.18);
        }

        /* Color button styling */
        .color-btn.color-blue { background-color: #3498db; }
        .color-btn.color-red { background-color: #e74c3c; }
        .color-btn.color-yellow { background-color: #f1c40f; }
    .color-btn.color-orange { background-color: #ff9800; }
        .color-btn.color-green { background-color: #2ecc71; }
        .color-btn.color-purple { background-color: #9b59b6; }
        .color-btn.color-white { background-color: #ffffff; border-color: #888; }
        .color-btn.color-black { background-color: #000000; }

        body {
            background: var(--bg-dark);
            color: var(--text-light);
            font-family: 'Noto Sans TC', Arial, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Èò≤Ê≠¢ÊªæÂãïÊ¢ùÂΩ±Èüø‰ΩàÂ±Ä */
        }

        .main-layout {
            display: flex;
            flex-direction: row;
            height: 100vh;
            width: 100vw;
        }

        /* ÂÅ¥ÈÇäÊ¨ÑÊ®£Âºè */
        .sidebar {
            /* ÂØ¨Â∫¶Âæû„ÄåÊØèÊó•Èñ±ËÆÄ„ÄçÁöÑ 240px Ë™øÊï¥ÁÇ∫ 300pxÔºåËÆìÁï´Â∏ÉÂçÄÂüüÊúâÊõ¥Â§öÁ©∫Èñì */
            width: 300px;
            background: #16213e; 
            box-shadow: 2px 0 16px #0006;
            padding: 24px;
            box-sizing: border-box; /* Á¢∫‰øù padding ‰∏çÂ¢ûÂä†Á∏ΩÂØ¨Â∫¶ */
            overflow-y: auto;
            display: flex; /* ËÆìÂÖßÈÉ®Â∑•ÂÖ∑ÁµÑÂûÇÁõ¥ÊéíÂàó */
            flex-direction: column;
        }

        .canvas-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-medium);
            height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            overflow: auto;
        }

        .toolbar-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding-bottom: 20px;
        }
        /* ÂêÑÂàÜÈöîÁ∑öÁç®Á´ãË®≠ÂÆö */
        .toolbar-group:nth-child(1) {
            border-bottom: 1px solid #16213e;
            margin-top: 2px;
        }
        .toolbar-group:nth-child(2) {
            border-bottom: 1px solid #16213e;
            padding-bottom: 0;
        }
        .toolbar-group:nth-child(3) {
            border-bottom: 1px solid #16213e;
            margin-top: 88px;
        }
        .toolbar-group:last-child {
            border-bottom: none;
        }

        .toolbar-group-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 4px;
            color: var(--primary-accent);
            text-align: center;
        }

        .toolbar-row {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
        }
        
        .sidebar button, .sidebar select, .sidebar input[type="range"] {
            font-family: inherit;
        }

        .sidebar label {
            white-space: nowrap;
        }

        .icon-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            background: transparent;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.18);
            border: 1px solid rgba(255,255,255,0.12);
            transition: background 0.2s, box-shadow 0.2s;
            padding: 0;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
        }

        .icon-btn.active {
            background: var(--primary-accent);
            color: #fff;
            border-color: var(--primary-accent);
        }
        
        .icon-btn:hover {
            background: #444;
        }
        
        .icon-btn:active {
            transform: translateY(1px);
        }

        .color-palette {
            display: flex;
            flex-wrap: wrap;
            flex-direction: row;
            gap: 8px;
            width: 72px;
            height: 80px;
        }
        #color-palette-desktop {
            margin-top: 24px;
        }

        .color-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid #fff;
            padding: 0;
            cursor: pointer;
            transition: border-color 0.2s, box-shadow 0.2s, transform 0.1s;
        }
        
        .color-btn:hover {
            transform: scale(1.1);
        }

        .color-btn.active {
            border-color: var(--primary-accent);
            box-shadow: 0 0 0 3px var(--primary-accent);
        }

        #eraser-btn-desktop.active, #eraser-btn-mobile.active {
            background: var(--danger-accent);
            border-color: var(--danger-accent);
        }

        .shape-select, .symmetry-select {
            background: #2a2a3a;
            color: #fff;
            border-radius: 8px;
            border: 1px solid #888;
            padding: 6px 12px;
            font-size: 1em;
            min-width: 60px;
            cursor: pointer;
        }

        #mandala-canvas {
            background: #fff;
            border-radius: 16px;
            box-shadow: 0 4px 24px #0006;
            touch-action: none;
            cursor: crosshair;
        }

        /* ÊâãÊ©üÁâàÂ∑¶ÂÅ¥ÈÇäÊ¨ÑÊ®£Âºè - Ëàá articles.html ‰∏ÄËá¥ */
        #sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: 240px;
            height: 100vh;
            background: #16213e;
            box-shadow: 2px 0 16px #0006;
            z-index: 200;
            transform: translateX(-100%);
            transition: transform 0.3s;
            overflow-y: auto;
        }
        
        #sidebar.show {
            transform: translateX(0);
        }
        
        #sidebar h2 {
            color: #00aaff;
            margin: 24px 0 16px 0;
            text-align: center;
            font-size: 1.2em;
            padding: 16px 0 8px 0;
        }
        
        .sidebar-link {
            display: block;
            padding: 12px 32px;
            color: #fff;
            font-size: 1.1em;
            text-decoration: none;
            text-align: center;
        }
        
        #sidebar-close {
            position: absolute;
            top: 16px;
            right: 16px;
        }
        
        /* ÊâãÊ©üÁâàÊº¢Â†°ÊåâÈàïÊ®£Âºè */
        #hamburger {
            box-shadow: 0 2px 8px #0004;
        }
        
        #hamburger svg {
            vertical-align: middle;
        }
        
        /* Mobile controls section */
        .controls-mobile {
            display: none;
        }
        
        /* Responsive design for smaller screens */
        @media (max-width: 768px) {
            .main-layout {
                flex-direction: column-reverse;
            }
            .sidebar {
                display: none;
            }

            .mobile-header-placeholder {
                width: 44px;
            }
            
            /* ÊâãÊ©üÁâàÊ®ôÈ°åÂçÄÂüüÂú®ÊâãÊ©ü‰∏äÈ°ØÁ§∫ */
            .mobile-header {
                display: flex;
            }
        }
        .mobile-header-placeholder {
            width: 44px;
        }
        .controls-mobile {
            display: flex;
            flex-direction: column;
            background: var(--bg-light);
            box-shadow: 0 -2px 16px var(--shadow-color);
            padding: 16px;
            gap: 16px;
            width: 100%;
            box-sizing: border-box;
            position: fixed;
            bottom: 0;
            left: 0;
            z-index: 10;
        }
        .controls-mobile .toolbar-row {
            justify-content: space-around;
            flex-wrap: wrap;
        }
        #brush-size-mobile {
            flex: 1;
        }
        .canvas-area {
            padding: 10px;
            padding-bottom: 200px;
            height: 100%;
            width: 100%;
            box-sizing: border-box;
        }
        #mandala-canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
        }
        .toolbar-group-title {
            display: none;
        }
        .toolbar-group {
            border-bottom: none;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }
        
        /* ÊâãÊ©üÁâàÊ®ôÈ°åÂçÄÂüüÊ®£Âºè */
        .mobile-header {
            display: none; /* Ê°åÈù¢ÁâàÈö±Ëóè */
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            background: rgba(30, 30, 45, 0.95);
            border-radius: 20px;
            margin: 16px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
        }
        
        .mobile-title {
            color: #e0e0e0;
            font-size: 1.5em;
            font-weight: 300;
            margin: 0;
            flex: 1;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- ÊâãÊ©üÁâàÊ®ôÈ°åÂçÄÂüü -->
    <div class="mobile-header">
        <button id="hamburger" class="icon-btn" title="Â±ïÈñãÈÅ∏ÂñÆ">
            <svg width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="4" y="6" width="16" height="2" rx="1" fill="currentColor"/>
                <rect x="4" y="11" width="16" height="2" rx="1" fill="currentColor"/>
        <div class="mobile-header-placeholder"></div> <!-- ‰Ωî‰ΩçÂÖÉÁ¥†Ôºå‰øùÊåÅÊ®ôÈ°åÁΩÆ‰∏≠ -->
            </svg>
        </button>
        <h1 class="mobile-title">Áπ™Áï´Â£áÂüé</h1>
        <div class="mobile-header-placeholder"></div> <!-- ‰Ωî‰ΩçÂÖÉÁ¥†Ôºå‰øùÊåÅÊ®ôÈ°åÁΩÆ‰∏≠ -->
    </div>

    <div class="main-layout">
        <div class="sidebar">
            <div class="toolbar-group">
                <div class="toolbar-group-title">ÈÅ∏ÂñÆ</div>
                <div class="toolbar-row">
                    <a href="meditation.html" class="icon-btn" title="ÂÜ•ÊÉ≥Èü≥Ê®Ç">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 17V5l12-2v12"/>
                            <circle cx="6" cy="17" r="3"/>
                            <circle cx="18" cy="16" r="3"/>
                        </svg>
                    </a>
                    <a href="articles.html" class="icon-btn" title="ÊØèÊó•Èñ±ËÆÄ">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 6v12a2 2 0 0 0 2 2h7"/>
                            <path d="M21 6v12a2 2 0 0 1-2 2h-7"/>
                            <path d="M3 6a2 2 0 0 1 2-2h7v16H5a2 2 0 0 1-2-2z" fill="none"/>
                            <path d="M21 6a2 2 0 0 0-2-2h-7v16h7a2 2 0 0 0 2-2z" fill="none"/>
                        </svg>
                    </a>
                    <a href="guidance.html" class="icon-btn" title="ÊØèÊó•ÊåáÂºï">
                         <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 2L12 22M2 12L22 12M12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2Z" fill="none" stroke="#fff" stroke-width="2"/>
                        </svg>
                    </a>
                </div>
            </div>
            <div class="toolbar-group">
                <div class="toolbar-group-title">Á≠ÜÂà∑</div>
                <div class="toolbar-row">
                    <label for="brush-size-desktop">Â§ßÂ∞èÔºö</label>
                    <input type="range" id="brush-size-desktop" min="1" max="100" value="10">
                    <div class="color-palette" id="color-palette-desktop">
                <div class="toolbar-row">
                    <!-- È°èËâ≤ÈÅ∏ÊìáÂçÄÂ°äÔºåÂ∑≤ÂæÄ‰∏ãË™øÊï¥ÔºåËàáÁπ™ÂúñÂ∑•ÂÖ∑ÂàÜÈöîÊõ¥ÊòéÈ°Ø -->
                    <div class="color-palette" id="color-palette-desktop">
                        <button class="color-btn color-black active" data-color="#000000" title="ÈªëËâ≤"></button>
                        <button class="color-btn color-red" data-color="#e74c3c" title="Á¥ÖËâ≤"></button>
                        <button class="color-btn color-orange" data-color="#ff9800" title="Ê©ôËâ≤"></button>
                        <button class="color-btn color-yellow" data-color="#f1c40f" title="ÈªÉËâ≤"></button>
                        <button class="color-btn color-green" data-color="#2ecc71" title="Á∂†Ëâ≤"></button>
                        <button class="color-btn color-blue" data-color="#3498db" title="ËóçËâ≤"></button>
                        <button class="color-btn color-purple" data-color="#9b59b6" title="Á¥´Ëâ≤"></button>
                        <button class="color-btn color-white" data-color="#ffffff" title="ÁôΩËâ≤"></button>
                    </div>
                </div>
            </div>
            <div class="toolbar-group">
                <div class="toolbar-group-title">Áπ™ÂúñÂ∑•ÂÖ∑</div>
                <!-- Áπ™ÂúñÂ∑•ÂÖ∑ÂçÄÂ°äÔºåÂ∑≤ÂæÄ‰∏ãË™øÊï¥ÔºåËàáÈ°èËâ≤ÂàÜÈöîÊõ¥ÊòéÈ°Ø -->
                <div class="toolbar-row" id="shape-tools-desktop">
                    <button class="icon-btn active" data-shape="freehand">Á≠Ü</button>
                    <button class="icon-btn" data-shape="line">Áõ¥Á∑ö</button>
                    <button class="icon-btn" data-shape="circle">ÂúìÂΩ¢</button>
                    <button class="icon-btn" data-shape="square">ÊñπÂΩ¢</button>
                    <button class="icon-btn" data-shape="triangle">‰∏âËßí</button>
                    <button class="icon-btn" data-shape="trapezoid">Ê¢ØÂΩ¢</button>
                </div>
                <div class="toolbar-row">
                    <label for="symmetry-count-desktop">Â∞çÁ®±Ôºö</label>
                    <select class="symmetry-select" id="symmetry-count-desktop">
                        <option value="0" selected>0</option>
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="4">4</option>
                        <option value="6">6</option>
                        <option value="8">8</option>
                        <option value="12">12</option>
                        <option value="16">16</option>
                    </select>
                </div>
            </div>
            <div class="toolbar-group">
                <div class="toolbar-group-title">Êìç‰Ωú</div>
                <div class="toolbar-row">
                    <button class="icon-btn" id="eraser-btn-desktop">Ê©°ÁöÆÊì¶</button>
                    <button class="icon-btn" id="undo-btn-desktop">‰∏ä‰∏ÄÊ≠•</button>
                    <button class="icon-btn" id="redo-btn-desktop">‰∏ã‰∏ÄÊ≠•</button>
                    <button class="icon-btn" id="clear-btn-desktop">Ê∏ÖÁ©∫</button>
                    <button class="icon-btn" id="save-btn-desktop">ÂÑ≤Â≠ò</button>
                </div>
            </div>
        </div>

        <div class="canvas-area">
            <canvas id="mandala-canvas"></canvas>
        </div>

        <div class="controls-mobile">
                    <input type="range" id="brush-size-mobile" min="1" max="100" value="10">
                <div class="toolbar-row">
                    <label for="brush-size-mobile">Â§ßÂ∞èÔºö</label>
                    <input type="range" id="brush-size-mobile" min="1" max="100" value="10">
                </div>
                <div class="toolbar-row" id="color-palette-mobile">
                    <button class="color-btn color-black active" data-color="#000000" title="ÈªëËâ≤"></button>
                    <button class="color-btn color-red" data-color="#e74c3c" title="Á¥ÖËâ≤"></button>
                    <button class="color-btn color-orange" data-color="#ff9800" title="Ê©ôËâ≤"></button>
                    <button class="color-btn color-yellow" data-color="#f1c40f" title="ÈªÉËâ≤"></button>
                    <button class="color-btn color-green" data-color="#2ecc71" title="Á∂†Ëâ≤"></button>
                    <button class="color-btn color-blue" data-color="#3498db" title="ËóçËâ≤"></button>
                    <button class="color-btn color-purple" data-color="#9b59b6" title="Á¥´Ëâ≤"></button>
                    <button class="color-btn color-white" data-color="#ffffff" title="ÁôΩËâ≤"></button>
                </div>
            </div>
            <div class="toolbar-group">
                <div class="toolbar-row" id="shape-tools-mobile">
                    <button class="icon-btn active" data-shape="freehand">Á≠Ü</button>
                    <button class="icon-btn" data-shape="line">‚îÄ</button>
                    <button class="icon-btn" data-shape="circle">‚óã</button>
                    <button class="icon-btn" data-shape="square">‚ñ°</button>
                    <button class="icon-btn" data-shape="triangle">‚ñ≥</button>
                    <button class="icon-btn" data-shape="trapezoid">Ê¢Ø</button>
                    <button class="icon-btn" id="eraser-btn-mobile">Êì¶</button>
                </div>
                <div class="toolbar-row">
                    <label for="symmetry-count-mobile">Â∞çÁ®±:</label>
                    <select class="symmetry-select" id="symmetry-count-mobile">
                        <option value="0" selected>0</option>
                        <option value="2">2</option>
                        <option value="4">4</option>
                        <option value="6">6</option>
                        <option value="8">8</option>
                        <option value="12">12</option>
                    </select>
                    <button class="icon-btn" id="undo-btn-mobile">‚Ü©Ô∏è</button>
                    <button class="icon-btn" id="redo-btn-mobile">‚Ü™Ô∏è</button>
                    <button class="icon-btn" id="clear-btn-mobile">üóëÔ∏è</button>
                    <button class="icon-btn" id="save-btn-mobile">üíæ</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ÊâãÊ©üÁâàÂ∑¶ÂÅ¥ÈÇäÊ¨Ñ - Ëàá articles.html ‰∏ÄËá¥ -->
    <nav id="sidebar">
        <h2>ÈÅ∏ÂñÆ</h2>
        <a href="meditation.html" class="sidebar-link">ÂÜ•ÊÉ≥Èü≥Ê®Ç</a>
        <a href="articles.html" class="sidebar-link">ÊØèÊó•Èñ±ËÆÄ</a>
        <a href="guide.html" class="sidebar-link">ÊØèÊó•ÊåáÂºï</a>
        <button id="sidebar-close" class="icon-btn" title="ÈóúÈñâÈÅ∏ÂñÆ">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
        </button>
    </nav>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        // --- DOM Element Selection ---
        const canvas = document.getElementById('mandala-canvas');
        const ctx = canvas.getContext('2d');
        const canvasArea = document.querySelector('.canvas-area');

        // ÊâãÊ©üÁâàÂÅ¥ÈÇäÊ¨ÑÊéßÂà∂
        const hamburgerBtn = document.getElementById('hamburger');
        const sidebarNav = document.getElementById('sidebar');
        const sidebarClose = document.getElementById('sidebar-close');
        
        hamburgerBtn.addEventListener('click', function() {
            sidebarNav.classList.toggle('show');
        });
        
        sidebarClose.addEventListener('click', function() {
            sidebarNav.classList.remove('show');
        });

        // Controls
        const controls = {
            brushSize: [document.getElementById('brush-size-desktop'), document.getElementById('brush-size-mobile')],
            colorPalettes: [document.getElementById('color-palette-desktop'), document.getElementById('color-palette-mobile')],
            eraserBtns: [document.getElementById('eraser-btn-desktop'), document.getElementById('eraser-btn-mobile')],
            symmetrySelects: [document.getElementById('symmetry-count-desktop'), document.getElementById('symmetry-count-mobile')],
            shapeTools: [document.getElementById('shape-tools-desktop'), document.getElementById('shape-tools-mobile')],
            undoBtns: [document.getElementById('undo-btn-desktop'), document.getElementById('undo-btn-mobile')],
            redoBtns: [document.getElementById('redo-btn-desktop'), document.getElementById('redo-btn-mobile')],
            clearBtns: [document.getElementById('clear-btn-desktop'), document.getElementById('clear-btn-mobile')],
            saveBtns: [document.getElementById('save-btn-desktop'), document.getElementById('save-btn-mobile')],
        };

        // --- State Variables ---
        let isDrawing = false; // For freehand drawing
        let isDraggingShape = false; // For drawing shapes
        let brushSize = 10;
        let brushColor = '#000000';
        let lastSelectedColor = '#000000'; // Store the last non-eraser color
        let symmetry = 0;
        let currentShape = 'freehand';
        let lastX = 0;
        let lastY = 0;
        let startX = 0;
        let startY = 0;
        let history = [];
        let historyIndex = -1;

        // --- Canvas Setup ---
        /**
         * Resizes the canvas to be a square based on the available space.
         * Restores the last saved image from history.
         */
        function resizeCanvas() {
            const size = Math.min(canvasArea.clientWidth, canvasArea.clientHeight) * 0.9;
            canvas.width = size;
            canvas.height = size;
            
            redrawFromHistory();
        }

        /**
         * Clears the canvas and saves the state.
         * @param {boolean} save - Whether to save the state to history.
         */
        function clearCanvas(save = true) {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (save) {
                saveState();
            }
        }

        /**
         * Initializes the canvas and saves the initial empty state.
         */
        function initializeCanvas() {
            resizeCanvas();
            clearCanvas(true);
        }

        // --- Drawing Logic ---
        /**
         * Gets the coordinates of the mouse or touch event relative to the canvas.
         */
        function getEventCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            return { x, y };
        }

        /**
         * Handles the start of a drawing or dragging action.
         */
        function handleCanvasMouseDown(e) {
            e.preventDefault();
            const coords = getEventCoordinates(e);
            
            if (currentShape === 'freehand') {
                isDrawing = true;
                [lastX, lastY] = [coords.x, coords.y];
            } else {
                isDraggingShape = true;
                [startX, startY] = [coords.x, coords.y];
            }
        }

        /**
         * Handles the movement of the mouse or touch.
         * Draws freehand lines or previews shapes.
         */
        function handleCanvasMouseMove(e) {
            if (isDrawing && currentShape === 'freehand') {
                const coords = getEventCoordinates(e);
                drawSymmetricalLines(lastX, lastY, coords.x, coords.y);
                [lastX, lastY] = [coords.x, coords.y];
            } else if (isDraggingShape) {
                drawPreview(e);
            }
        }
        
        /**
         * Handles the end of a drawing or dragging action.
         * Draws the final shape and saves the state.
         */
        function handleCanvasMouseUp(e) {
            if (isDrawing) {
                isDrawing = false;
                ctx.beginPath();
                saveState();
            } else if (isDraggingShape) {
                isDraggingShape = false;
                const coords = getEventCoordinates(e);
                drawFinalShape(startX, startY, coords.x, coords.y);
                saveState();
            }
            
            redrawFromHistory();
        }
        
        /**
         * Draws a line with the current symmetry settings.
         */
        function drawSymmetricalLines(x1, y1, x2, y2) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const segments = symmetry === 0 ? 1 : symmetry;

            for (let i = 0; i < segments; i++) {
                const angle = (Math.PI * 2 / segments) * i;
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(angle);
                
                ctx.beginPath();
                ctx.moveTo(x1 - centerX, y1 - centerY);
                ctx.lineTo(x2 - centerX, y2 - centerY);
                ctx.strokeStyle = brushColor;
                ctx.lineWidth = brushSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
                
                if (symmetry > 0) {
                    ctx.scale(1, -1);
                    ctx.beginPath();
                    ctx.moveTo(x1 - centerX, y1 - centerY);
                    ctx.lineTo(x2 - centerX, y2 - centerY);
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

        /**
         * Draws the final shape with symmetry.
         */
        function drawFinalShape(x1, y1, x2, y2) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const segments = symmetry === 0 ? 1 : symmetry;

            for (let i = 0; i < segments; i++) {
                const angle = (Math.PI * 2 / segments) * i;
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(angle);
                
                drawShape(x1 - centerX, y1 - centerY, x2 - centerX, y2 - centerY);
                
                if (symmetry > 0) {
                    ctx.scale(1, -1);
                    drawShape(x1 - centerX, y1 - centerY, x2 - centerX, y2 - centerY);
                }
                ctx.restore();
            }
        }

        /**
         * Encapsulates all shape drawing logic.
         * @param {number} x1 - Start x coordinate.
         * @param {number} y1 - Start y coordinate.
         * @param {number} x2 - End x coordinate.
         * @param {number} y2 - End y coordinate.
         * @param {boolean} isPreview - Whether to draw a preview shape.
         */
        function drawShape(x1, y1, x2, y2, isPreview = false) {
            ctx.strokeStyle = isPreview ? "rgba(100, 100, 100, 0.7)" : brushColor;
            ctx.lineWidth = isPreview ? Math.max(2, brushSize / 10) : brushSize;
            ctx.setLineDash(isPreview ? [8, 6] : []);

            switch (currentShape) {
                case 'line':
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    break;
                case 'circle':
                    const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                    ctx.beginPath();
                    ctx.arc(x1, y1, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    break;
                case 'square':
                    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                    break;
                case 'triangle':
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x1 + (x1 - x2), y2);
                    ctx.closePath();
                    ctx.stroke();
                    break;
                case 'trapezoid':
                    ctx.beginPath();
                    ctx.moveTo(x1 - (x2 - x1) / 4, y2);
                    ctx.lineTo(x2 + (x2 - x1) / 4, y2);
                    ctx.lineTo(x2, y1);
                    ctx.lineTo(x1, y1);
                    ctx.closePath();
                    ctx.stroke();
                    break;
            }
        }

        /**
         * Draws a preview of the shape being dragged.
         */
        function drawPreview(e) {
            redrawFromHistory();
            const coords = getEventCoordinates(e);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const segments = symmetry === 0 ? 1 : symmetry;

            for (let i = 0; i < segments; i++) {
                const angle = (Math.PI * 2 / segments) * i;
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(angle);
                
                drawShape(startX - centerX, startY - centerY, coords.x - centerX, coords.y - centerY, true);
                
                if (symmetry > 0) {
                    ctx.scale(1, -1);
                    drawShape(startX - centerX, startY - centerY, coords.x - centerX, coords.y - centerY, true);
                }
                ctx.restore();
            }
        }

        // --- History (Undo/Redo) Logic ---
        /**
         * Saves the current canvas state to the history array.
         */
        function saveState() {
            if (historyIndex < history.length - 1) {
                history.splice(historyIndex + 1);
            }
            history.push(canvas.toDataURL());
            historyIndex++;
        }

        /**
         * Goes back one step in the history.
         */
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                redrawFromHistory();
            }
        }

        /**
         * Goes forward one step in the history.
         */
        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                redrawFromHistory();
            }
        }
        
        /**
         * Clears the canvas and redraws the image from the current history state.
         */
        function redrawFromHistory() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (history[historyIndex]) {
                const img = new Image();
                img.src = history[historyIndex];
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                };
            }
        }
        
        // --- Control Handlers ---
        function handleBrushSizeChange(e) {
            brushSize = e.target.value;
            controls.brushSize.forEach(slider => slider.value = brushSize);
        }

        function handleColorChange(e) {
            const button = e.target.closest('.color-btn');
            if (!button) return;
            
            brushColor = button.dataset.color;
            lastSelectedColor = brushColor;
            
            updateActiveTool(document.querySelector(`button[data-shape="freehand"]`));
            
            controls.colorPalettes.forEach(palette => {
                palette.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('active'));
                palette.querySelectorAll(`.color-btn[data-color="${brushColor}"]`).forEach(btn => btn.classList.add('active'));
            });
        }
        
        function handleShapeChange(e) {
            const button = e.target.closest('.icon-btn[data-shape]');
            if (!button) return;
            
            currentShape = button.dataset.shape;
            updateActiveTool(button);
            
            // Reset colors and eraser state when changing shape
            brushColor = lastSelectedColor;
            controls.eraserBtns.forEach(btn => btn.classList.remove('active'));
            controls.colorPalettes.forEach(palette => {
                palette.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('active'));
                palette.querySelectorAll(`.color-btn[data-color="${lastSelectedColor}"]`).forEach(btn => btn.classList.add('active'));
            });
        }

        function handleEraserToggle() {
            const eraserIsActive = controls.eraserBtns[0].classList.contains('active');
            
            if (eraserIsActive) {
                // Deactivate eraser: revert to last selected color and freehand mode
                brushColor = lastSelectedColor;
                updateActiveTool(document.querySelector(`button[data-shape="freehand"]`));
                controls.colorPalettes.forEach(palette => {
                    palette.querySelectorAll(`.color-btn[data-color="${brushColor}"]`).forEach(btn => btn.classList.add('active'));
                });
            } else {
                // Activate eraser: set color to white and mark as active
                brushColor = '#ffffff';
                updateActiveTool(controls.eraserBtns[0]);
                controls.colorPalettes.forEach(palette => {
                    palette.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('active'));
                });
            }
        }
        
        /**
         * Updates the 'active' class for the selected tool buttons across all toolbars.
         */
        function updateActiveTool(activeButton) {
            // Remove 'active' from all shape and eraser buttons
            document.querySelectorAll('.icon-btn[data-shape]').forEach(btn => btn.classList.remove('active'));
            controls.eraserBtns.forEach(btn => btn.classList.remove('active'));
            
            // Add 'active' to the corresponding buttons in both desktop and mobile toolbars
            if (activeButton.dataset.shape) {
                const shape = activeButton.dataset.shape;
                document.querySelectorAll(`.icon-btn[data-shape="${shape}"]`).forEach(btn => btn.classList.add('active'));
            } else {
                controls.eraserBtns.forEach(btn => btn.classList.add('active'));
            }
        }

        function handleSymmetryChange(e) {
            symmetry = parseInt(e.target.value, 10);
            controls.symmetrySelects.forEach(select => select.value = symmetry);
        }

        function saveCanvas() {
            const link = document.createElement('a');
            link.download = 'mandala.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // --- Event Listeners ---
        canvas.addEventListener('mousedown', handleCanvasMouseDown);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        canvas.addEventListener('mouseup', handleCanvasMouseUp);
        canvas.addEventListener('mouseleave', () => {
            if (isDrawing || isDraggingShape) {
                isDrawing = false;
                isDraggingShape = false;
                redrawFromHistory();
            }
        });
        canvas.addEventListener('touchstart', handleCanvasMouseDown, { passive: false });
        canvas.addEventListener('touchmove', handleCanvasMouseMove, { passive: false });
        canvas.addEventListener('touchend', handleCanvasMouseUp);
        
        window.addEventListener('resize', resizeCanvas);

        controls.brushSize.forEach(slider => slider.addEventListener('input', handleBrushSizeChange));
        controls.colorPalettes.forEach(palette => palette.addEventListener('click', handleColorChange));
        controls.shapeTools.forEach(toolbar => toolbar.addEventListener('click', handleShapeChange));
        controls.eraserBtns.forEach(btn => btn.addEventListener('click', handleEraserToggle));
        controls.symmetrySelects.forEach(select => select.addEventListener('change', handleSymmetryChange));
        controls.undoBtns.forEach(btn => btn.addEventListener('click', undo));
        controls.redoBtns.forEach(btn => btn.addEventListener('click', redo));
        controls.clearBtns.forEach(btn => btn.addEventListener('click', () => clearCanvas(true)));
        controls.saveBtns.forEach(btn => btn.addEventListener('click', saveCanvas));
        
        // --- Initialization ---
        initializeCanvas();
    });
</script>
</body>
</html>